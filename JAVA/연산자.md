# 목차


- [목차](#목차)
- [연산자의 우선순위](#연산자의-우선순위)
- [산술 변환](#산술-변환)
- [단항 연산자](#단항-연산자)
- [산술 연산자](#산술-연산자)
	- [소수점 원하는 자리수까지 출력](#소수점-원하는-자리수까지-출력)
- [비교 연산자](#비교-연산자)
- [논리 연산자](#논리-연산자)
	- [단락 회로 평가(short circuit evaluation)](#단락-회로-평가short-circuit-evaluation)
- [비트 연산자](#비트-연산자)
	- [쉬프트 연산자](#쉬프트-연산자)

<br>

## 연산자의 우선순위
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항 > 이항 > 삼항. 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산자의 진행방향은 왼쪽에서 오른쪽이다.
4. 쉬프트 연산자 (<<)는 덧셈 연잔자보다 우선 순위가 낮다.
    ex) `x << 2+1` -> `x << 3`
5. 비트 연산자는 비교연산자보다 우선 순위가 낮다.
    ex) `data & 0xFF == 0`
6. 논리 연산자 중에서 AND를 의미하는 `&`, `&&`이 OR을 의미하는 `|`, `||` 보다 우선순위가 높다. 괄호를 사용하여 우선순위를 명확히 하는 것이 좋다.

![image](https://user-images.githubusercontent.com/106129404/226787282-8a208bbf-793e-48e3-8c5e-a83bb2bfe678.png)

## 산술 변환
- 산술변환 : 연산 수행 직전 일어나는 피연산자의 **자동 형변환**
- 산술변환의 두 가지 규칙
1. 두 피연산자의 타입을 같은 타입으로 일치시킨다(표현 범위가 큰 타입으로 일치). ex) `int + float = float`
2. 피연산자의 타입이 int보다 작은 타입인 경우 int로 변환된다. ex) `byte + short = int`, `char + short = int`
- 산술 변환은 비교연산시에도 일어나 자동 형변환한다. ex) `10 == 10.0; // true`
## 단항 연산자
- 증감연산자의 전위형(++i)과 후위형(i++)은 수식이나 메서드 호출에 포함된 경우 결과가 다르다.
- 수식이나 메서드 호출에 포함되지 않고 독립정인 하나의 문장으로 쓰인 경우에는 차이가 없다.
- 하나의 식에 두 번 이상 사용된 변수에 증감 연산자를 사용하는 것은 피한다.

## 산술 연산자
- 정수를 0으로 나누면 ArithmeticException 발생, 실수를 0으로 나오면 결과는 Infinity이다.
- 산술중 충분히 큰 자료형을 사용하지 않으면 오버플로우로 값 손실이 발생할 수 있다.
- 산술변환은 대입연산자에서 이루어지지 않고 산술연산자에서 이루어지므로, 형변환시 피연산자중 하나의 타입을 형변환한다.
    ```java
    int a = 1_000_000;
    int b = 2_000_000;
    long c = a * b; // a * b는 int이므로 연산중 오버플로우가 발생한 값을 그대로 c에 대입한다.
    System.out.println(c); // -1454749936
    
    long c = a * (long)b; // long으로 산술 형변환이 자동으로 이루어지므로 
    System.out.println(c); // 2000000000000
    ```
- **상수 또는 리터럴 간의 연산은 컴파일러가 미리 연산을 수행**한다.
- 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산할수 없어 형변환이 필요하다.
    ```java
    char c1 = 'a';
    char c2 = c1 + 1; // 컴파일 에러 발생. 변수가 있어 컴파일러가 미리 연산할 수 없으므로 명시적 형변환 필요
    char c2 = 'a'+1; // 연산 결과가 int형이지만 리터럴은 컴파일러가 미리 연산하므로 ok
    ```

### 소수점 원하는 자리수까지 출력
- 실수형 변수를 원하는 자리수까지 출력하는 법
- 곱해서 정수형으로 형변환하여 소수점 아래를 버린 후, 실수형으로 다시 나눈다.
	```java
	float pi = 3.141592f;
	float shortPi = (int) (pi * 1000) / 1000f; 
	// 3.141
 	```
- 반올림을 하려면 `Math.round()`를 활용한다.
- `Math.round()` 메소드는 소수 첫째 자리에서 반올림 후, 정수를 반환한다.
	```java
	double pi = 3.141592;
	double shortPi = Math.round(pi * 1000) / 1000.0;
	// 3.142
	```

## 비교 연산자
- 서로 다른 타입의 실수 float, double를 비교할 때는 float으로 변환한다.
- float은 2진수로 변환하여 저장하며 오차가 생기기 때문이다.
	``` java
	float f = 0.1f;
	double d = 0.1;
	d == f // false
	(float) d == f // true
	```
- 문자열을 비교할 때는 비교 연산자(==)가 아닌 String.equals() 메소드를 사용한다.
- String 객체를 `==`로 비교하면 서로 다른 객체이므로 false를 얻는다.

## 논리 연산자
- `&&`연산자가 `||`연산자보다 우선순위가 높다.
- 하나의 식에 `&&`와 `||`이 같이 포함된 경우 괄호를 사용해서 우선순위를 명확히 해주는 것이 좋다.
- 논리 부정 연산자 `!` 는 true면 false로, false면 true로 바꾸어 반환한다.

### 단락 회로 평가(short circuit evaluation)

- 논리 연산에서 모든 항이 실행되지 않는 경우
- `&&`은 두 항의 결과가 모두 true일 때 true
    - 앞 항이 false이면 뒤의 항을 평가하지 않음
- `||`은 두 항의 결과가 모두 false일 때 false
    - 앞 항이 true이면 뒤의 항을 평가하지 않음
- 조건에 따라 `&&`면 앞 항이 false일 가능성, `||`면 앞 항이 true일 가능성이 높은 조건을 배치하는 것이 효율적이다.

## 비트 연산자

![image](https://user-images.githubusercontent.com/106129404/225191310-3d944a5f-bb20-4280-868e-7b660c9a26cd.png)

- 같은 값을 두고 비트연산자`^`으로 XOR을 두번 수행하면 원래의 값으로 돌아오는 특징이 있다. ex) `x^y= z, z^y = x`

### 쉬프트 연산자
- `<<`연산자는 부호에 상관없이 각 자리를 왼쪽으로 이동시켜 빈칸을 0으로 채운다.
- `>>`연산자는 값이 작아져도 부호는 유지하기 위해 피연산자가 음수인 경우는 빈칸을 1, 양수인 경우는 빈칸을 0으로 채운다.
- `<<`연산자는 값이 커지므로 int타입으로 자동 산술변환된다.
- `>>`연산자는 값이 작아지므로 산술변환이 적용되지 않는다.
- `x << n`은 `x * 2^n`, `x >> n`은 `x / 2^n`의 결과와 같다.
- n의 값이 자료형의 비트 수보다 크면 비트 수로 나눈 나머지만큼만 이동한다. ex) `(int) x >> 33 == (int) x >> 1`
- 가독성을 위해 곱셈이나 나눗셈 연산을 사용하고, 프로그램의 빠른 실행속도가 요구되는 곳에서만 쉬프트 연산자를 사용한다.

