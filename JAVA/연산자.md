# 목차


- [목차](#목차)
- [연산자의 우선순위](#연산자의-우선순위)
- [산술 변환](#산술-변환)
- [단항 연산자](#단항-연산자)
- [산술 연산자](#산술-연산자) 
- [비트 연산자](#비트-연산자)
- [단락 회로 평가(short circuit evaluation)](#단락-회로-평가short-circuit-evaluation)

<br>

## 연산자의 우선순위
1. 산술 > 비교 > 논리 > 대입. 대입은 제일 마지막에 수행된다.
2. 단항 > 이항 > 삼항. 단항 연산자의 우선순위가 이항 연산자보다 높다.
3. 단항 연산자와 대입 연산자를 제외한 모든 연산자의 진행방향은 왼쪽에서 오른쪽이다.
4. 쉬프트 연산자 (<<)는 덧셈 연잔자보다 우선 순위가 낮다.
    ex) `x << 2+1` -> `x << 3`
5. 비트 연산자는 비교연산자보다 우선 순위가 낮다.
    ex) `data & 0xFF == 0`
6. 논리 연산자 중에서 AND를 의미하는 `&`, `&&`이 OR을 의미하는 `|`, `||` 보다 우선순위가 높다. 괄호를 사용하여 우선순위를 명확히 하는 것이 좋다.

![image](https://user-images.githubusercontent.com/106129404/226787282-8a208bbf-793e-48e3-8c5e-a83bb2bfe678.png)

## 산술 변환
- 산술변환 : 연산 수행 직전 일어나는 피연산자의 **자동 형변환**
- 산술변환의 두 가지 규칙
1. 두 피연산자의 타입을 같은 타입으로 일치시킨다(표현 범위가 큰 타입으로 일치). ex) `int + float = float`
2. 피연산자의 타입이 int보다 작은 타입인 경우 int로 변환된다. ex) `byte + short = int`, `char + short = int`

## 단항 연산자
- 증감연산자의 전위형(++i)과 후위형(i++)은 수식이나 메서드 호출에 포함된 경우 결과가 다르다.
- 수식이나 메서드 호출에 포함되지 않고 독립정인 하나의 문장으로 쓰인 경우에는 차이가 없다.
- 하나의 식에 두 번 이상 사용된 변수에 증감 연산자를 사용하는 것은 피한다.

## 산술 연산자
- 정수를 0으로 나누면 ArithmeticException 발생, 실수를 0으로 나오면 결과는 Infinity이다.
- 산술중 충분히 큰 자료형을 사용하지 않으면 오버플로우로 값 손실이 발생할 수 있다.
- 산술변환은 대입연산자에서 이루어지지 않고 산술연산자에서 이루어지므로, 형변환시 피연산자중 하나의 타입을 형변환한다.
    ```java
    int a = 1_000_000;
    int b = 2_000_000;
    long c = a * b; // a * b는 int이므로 연산중 오버플로우가 발생한 값을 그대로 c에 대입한다.
    System.out.println(c); // -1454749936
    
    long c = a * (long)b; // long으로 산술 형변환이 자동으로 이루어지므로 
    System.out.println(c); // 2000000000000
    ```
- **상수 또는 리터럴 간의 연산은 컴파일러가 미리 연산을 수행**한다.
- 수식에 변수가 들어가 있는 경우에는 컴파일러가 미리 계산할수 없어 형변환이 필요하다.
    ```java
        char c1 = 'a';
        char c2 = c1 + 1; // 컴파일 에러 발생. 변수가 있어 컴파일러가 미리 연산할 수 없으므로 명시적 형변환 필요
	    char c2 = 'a'+1; // 연산 결과가 int형이지만 리터럴은 컴파일러가 미리 연산하므로 ok
    ```
 
## 비트 연산자

![image](https://user-images.githubusercontent.com/106129404/225191310-3d944a5f-bb20-4280-868e-7b660c9a26cd.png)

## 단락 회로 평가(short circuit evaluation)

- 논리 연산에서 모든 항이 실행되지 않는 경우
- &&은 두 항의 결과가 모두 True일 때 True
    - 앞 항이 false이면 뒤의 항을 평가하지 않음
- ||은 두 항의 결과가 모두 False일 때 False
    - 앞 항이 True이면 뒤의 항을 평가하지 않음


