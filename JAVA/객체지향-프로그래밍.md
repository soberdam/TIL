# 목차

- [목차](#목차)
- [자바 객체지향 프로그래밍](#자바-객체지향-프로그래밍)
    - [함수 호출과 스택 메모리](#함수-호출과-스택-메모리)
    - [인스턴스 (instance)](#인스턴스-instance)
    - [힙 메모리](#힙-메모리)
    - [참조 변수, 참조 값](#참조-변수-참조-값)
    - [접근 제어 지시자](#접근-제어-지시자)
    - [메소드의 입력](#메소드의-입력)
    - [메소드의 출력](#메소드의-출력)
    - [정보 은닉을 통한 캡슐화](#정보-은닉을-통한-캡슐화)
- [생성자](#생성자)
    - [this가 하는 일](#this가-하는-일)
        - [생성자에서 다른 생성자를 호출하는 this](#생성자에서-다른-생성자를-호출하는-this)
- [클래스와 인스턴스](#클래스와-인스턴스)
- [Static 변수](#static-변수)
    - [변수의 유효범위](#변수의-유효범위)
    - [싱글톤 패턴(singleton pattern) - static 응용](#싱글톤-패턴singleton-pattern---static-응용)
- [객체 배열](#객체-배열)
    - [객체 배열을 구현한 클래스 ArrayList](#객체-배열을-구현한-클래스-arraylist)
        - [ArrayList의 주요 메소드](#arraylist의-주요-메소드)
- [상속 (extends)](#상속-extends)
    - [super() - 하위 클래스가 생성되는 과정](#super---하위-클래스가-생성되는-과정)
- [상속은 언제 사용할까 ?](#상속은-언제-사용할까-)
    - [IS-A 관계(is a relationship : inheritance)](#is-a-관계is-a-relationship-inheritance)
    - [HAS-A 관계(composition)](#has-a-관계composition)
- [형 변환 (업캐스팅)](#형-변환-업캐스팅)
    - [형 변환과 오버라이딩 메소드 호출](#형-변환과-오버라이딩-메소드-호출)
    - [메소드는 어떻게 실행되고 호출되는가?](#메소드는-어떻게-실행되고-호출되는가)
    - [가상 메소드의 원리](#가상-메소드의-원리)
- [다형성(polymorphism)](#다형성polymorphism)
    - [다형성을 사용하는 이유](#다형성을-사용하는-이유)
    - [다운캐스팅](#다운캐스팅)
    - [instanceof를 사용하여 인스턴스의 형 체크](#instanceof를-사용하여-인스턴스의-형-체크)
- [추상클래스](#추상클래스)
    - [추상클래스란?](#추상클래스란)
    - [추상클래스 구현하기](#추상클래스-구현하기)
    - [템플릿 메소드](#템플릿-메소드)
        - [템플릿 메소드 예제](#템플릿-메소드-예제)
    - [hookup method](#hookup-method)
    - [final 예약어](#final-예약어)
- [인터페이스 (implements)](#인터페이스-implements)
    - [인터페이스와 다형성](#인터페이스와-다형성)
    - [default 메소드(Java 8 이후)](#default-메소드java-8-이후)
    - [default 메소드가 중복되는 경우](#default-메소드가-중복되는-경우)
    - [정적 메소드(Java 8 이후)](#정적-메소드java-8-이후)
    - [private 메소드(Java 9 이후)](#private-메소드java-9-이후)
    - [인터페이스의 상속](#인터페이스의-상속)
- [내부 클래스](#내부-클래스)
	- [인스턴스 내부 클래스](#인스턴스-내부-클래스)
	- [정적 내부 클래스](#정적-내부-클래스)
	- [지역 내부 클래스](#지역-내부-클래스)
	- [익명 내부 클래스](#익명-내부-클래스)

<br>

# 자바 객체지향 프로그래밍

## 함수 호출과 스택 메모리

- 스택 메모리 : 함수가 호출될 때 지역변수들이 사용하는 메모리
- 함수의 수행이 끝나면 자동으로 반환되는 메모리

![image](https://user-images.githubusercontent.com/106129404/225194842-8821cdd7-4021-4874-bb3f-5be5c6951181.png)

- 스택처럼 후입 선출의 구조로 순서대로 호출하고, 역순으로 실행한다.


## 인스턴스 (instance)

- 클래스는 객체의 속성을 정의하고 기능을 구현하여 만들어 놓은 코드 상태
- 클래스를 기반으로 생성된 실제 객체(인스턴스)는 각각 다른 멤버변수를 가진다.
- new 키워드를 사용하여 인스턴스 생성


## 힙 메모리

- 생성된 인스턴스는 동적 메모리(heap memory) 에 할당됨
- C나 C++ 언어에서는 사용한 동적 메모리를 프로그래머가 해제 시켜야 함 ( free() , delete 이용)
- 자바에서 Gabage Collector 가 주기적으로 사용하지 않는 메모리를 수거
- 하나의 클래스로부터 여러개의 인스턴스가 생성되고 각각 다른 메모리 주소를 가진다.


## 참조 변수, 참조 값

- 참조 변수 : 메모리에 생성된 인스턴스를 가리키는 변수
- 참조 값 : 생성된 인스턴스의 메모리 주소 값(실제 피지컬 주소가 아닌 해시코드값)


## 접근 제어 지시자

- private : 같은 클래스 내에서만 접근 가능
    - 멤버 변수(속성)는 private으로, set과 get메소드로 접근하는게 좋다.
- default : 같은 패키지 내에서만 접근 가능
- protected : 같은 패키지와 상속된 클래스에서 접근 가능
- public : 어디서든 접근 가능
- 정보의 은닉을 위해 사용한다.


## 메소드의 입력

- 인자(arguments) : 매개변수에 실제 전달되는 입력값

- 매개변수(parameter) : 메소드에서 인자를 담아 매개해주는 변수


## 메소드의 출력

- 반환타입
    
    void : 메소드가 반환하는 return 값이 없을 때 (바로 출력하거나, 다른 기능을 하는 메소드)
    
    int,double,String …  : 메소드가 반환하는 return 값의 타입
    
- Static
    
    static → class 소속의 객체/메소드. 정적으로 일회성 사용할 때 유용
    
    non-static → instance 소속의 객체/메소드. 동적으로 긴 맥락에서 사용할 때 유용
    
    ```jsx
    class Print {
    	public String delimiter;
    	
    	// 인스턴스를 생성해서 호출하는 메소드
    	public void a() {
    		System.out.println(this.delimiter);
    		System.out.println("a");
    		System.out.println("a");
    	}
    	
    	// 클래스에서 호출하는 메소드
    	public static void b(String delimiter) {
    		System.out.println(delimiter);
    		System.out.println("b");
    		System.out.println("b");
    	}
    	
    }
    
    public class staticMedthod {
    
    	public static void main(String[] args) {
    		
    		Print t1 = new Print();
    		t1.delimiter = "-";
    		t1.a();
    		
    		Print.b("*");
    	}
    
    }
    ```
    

## 정보 은닉을 통한 캡슐화

- 꼭 필요한 정보와 기능만 외부에 오픈함
- 정보를 클래스화해서 변수와 메소드를 감추고(private) 외부에 통합된 인터페이스를 제공하여 기능을 구현하게 함
- 메소드나 멤버변수에 접근함으로써 발생하는 오류를 최소화한다.
- 객체에 정보를 모아 감추고 외부에는 문제를 일으키지 않는 변수와 메소드만 인터페이스를 통해 제공한다.


# 생성자

- 클래스의 이름과 같은 메소드를 정의하여 초기화(초기값 설정)을 할 수 있다. 인스턴스를 생성하는데에 꼭 필요한 변수가 생성할 때 초기화되도록 한다.
- static이나 반환타입이 없다.
- this. 라는 키워드는 인스턴스화 되었을 때 그 인스턴스를 가리킨다.


## this가 하는 일

- 인스턴스 자신의 메모리를 가리킴
- 생성자에서 또다른 생성자를 호출할 때 사용
- 자신의 참조값(주소)을 반환
- 생성된 인스턴스 메모리의 주소를 가진다.

![image](https://user-images.githubusercontent.com/106129404/225195039-2b7e7c18-523f-4780-977d-c27e63402a70.png)


### 생성자에서 다른 생성자를 호출하는 this

- 생성자에서 다른 생성자를 호출하는 경우, this()statement 이전에 다른 statement가 올 수 없다(아직 인스턴스의 생성이 불완전하기 때문에)

```java
public class Person{
	private String name;
	private int Id;
	public Person(){
		// 이곳에 statement가 올 수 없습니다.
		this("이름없음", 1);
	}
	
	public Person(String name, int Id){
		this.name = name;
		this.Id = Id;
	}
}
```


# 클래스와 인스턴스

- 클래스 변수 / 메소드를 변경(클래스에서든, 특정 인스턴스 내부에서든)하면 모든 곳에서 변수/메소드가 변화(정적, 일정하게 변화)
- 인스턴스의 변수/메소드는 각각의 인스턴스에 저장되므로 그 안에서만 변화(동적, 개별로 변화)
- 클래스(static)는 인스턴스 변수/메소드(non-static)을 호출할 수 없지만 인스턴스(non-static)는 클래스(static) 변수/메소드를 호출할 수 있다.

![image](https://user-images.githubusercontent.com/106129404/225195076-9658cdcd-49a2-4ac1-a49e-d4e6e747719a.png)

```jsx
class Foo {
	
	public static String classVar = "I class Var";
	public String instanceVar = "I instance Var";
	
	public static void classMethod() {
		System.out.println(classVar); // OK
//		System.out.println(instanceVar); //Error
	}
	
	public void instanceMethod() {
		System.out.println(classVar); // OK
		System.out.println(instanceVar); // OK
	}
	
}

public class StaticApp {

	public static void main(String[] args) {
		
		System.out.println(Foo.classVar); // OK
//		System.out.println(Foo.instanceVar); // Error
		Foo.classMethod(); // OK
//		Foo.instanceMethod(); // Error
		
		Foo f1 = new Foo();
		Foo f2 = new Foo();
		
		System.out.println(f1.classVar); // I class Var
		System.out.println(f1.instanceVar); // I instance Var
		
		f1.classVar = "Changed class Var";
		f1.instanceVar = "Changed instance Var";
		
		System.out.println(Foo.classVar); // Changed class Var
		System.out.println(f2.classVar); // Changed class Var
		System.out.println(f2.instanceVar); // I instance Var
		
	}

}
```


# Static 변수

- static(클래스)는 인스턴스가 공유하는 기준 값.
- 클래스에서 바로 접근가능
- non-static(인스턴스)는 인스턴스를 생성해서 인스턴스에서 접근할 변수/메소드
- 인스턴스가 생성될 때 만들어지는 게 아닌, 프로그램이 메모리에 할당 될 때 메모리 할당
- 클래스 변수, 정적 변수라고도 함(vs 인스턴스 변수)
- 데이터 영역 메모리에 저장됨 (vs 힙 메모리)

![image](https://user-images.githubusercontent.com/106129404/225195114-5605dfc1-756f-4cf7-86af-24567897e9fc.png)

## 변수의 유효범위

![image](https://user-images.githubusercontent.com/106129404/225195144-7cbb41ed-6dee-446f-aa50-7b0d67df47b9.png)

- static 변수는 프로그램이 메모리에 있는 동안 계속 영역을 차지하므로 너무 큰 메모리를 할당하는 것은 좋지 않음
- 멤버변수가 너무 많으면 인스턴스 생성시마다 너무 많은 힙 메모리가 할당되므로 매개변수를 적절하게 이용한다


## 싱글톤 패턴(singleton pattern) - static 응용

- 인스턴스가 하나만 생성되어야 하는 경우 사용하는 디자인 패턴
- 객체를 하나로 관리
- 웹서비스에서는 커넥션 풀 생성 같은 경우에 사용
- 인스턴스가 여러개 생성되거나 값이 다양해지면 문제가 될 때 사용 ex) Calendar class

```java
public class School {
	private static School instance = new School();
	
	private School() {
	
	}
	
	public static School getInstance() {
		if(instance == null) {
			instance = new School();
		}
		return instance;
	}
}

import java.util.Calendar;

public class SchoolTest {

	public static void main(String[] args) {
		School school1 = School.getInstance();
		
		School school2 = School.getInstance();
		
		System.out.println(school1 == school2);
		
		Calendar calendar = Calendar.getInstance();
		
	}

}
```


# 객체 배열

- 기본 자료형 배열은 선언과 동시에 배열의 크기 * 자료형의 메모리 만큼의 메모리가 할당되지만, 객체 배열의 경우엔 객체의 주소가 들어갈 메모리(4바이트, 8바이트)만 할당됨
- 각 요소 객체는 생성하여 저장하여야 한다


## 객체 배열을 구현한 클래스 ArrayList

- java.util 패키지에서 제공
- 기존의 배열은 크기를 정하고 요소의 개수가 배열보다 커지면 배열을 새로 선언하고 재할당 해야했음
- 배열의 요소를 추가하거나 삭제하면 다른 요소들의 이동에 대한 구현을 해야함
- ArrayList는 객체 배열을 더 효율적으로 관리하기 위해 자바에서 제공하는 클래스


### ArrayList의 주요 메소드

![image](https://user-images.githubusercontent.com/106129404/225195200-a011527e-5b46-4c8f-a2e2-2704991b99be.png)


# 상속 (extends)

```java
class B extends A {

}
```

- 이미 구현된 클래스에서 속성이나 기능을 확장할 때 상속하여 클래스를 구현함
- `super`은 부모 클래스를 가리킴.
- 생성자가 있는 부모클래스를 상속받았다면, 자식클래스는 부모클래스의 생성자를 반드시 호출한다.
- 자식클래스는 하나의 부모클래스만을 가짐 (자바는 하나의 클래스만 상속 가능)


## super() - 하위 클래스가 생성되는 과정

- 하위클래스를 생성하면 상위클래스가 먼저 생성됨
- 클래스가 상속받은 경우 하위클래스는 상위클래스의 생성자를 반드시 호출한다
- super()는 상위 클래스의 기본 생성자를 호출한다.
- 하위클래스에서 명시적으로 상위클래스를 호출하지 않으면 super()가 호출된다(이 때 상위클래스의 기본생성자가 존재해야 함)
- 만약 상위클래스에 기본 생성자가 없고 다른 파라미터를 받는 생성자를 갖고 있다면 하위클래스의 생성자에서 명시적으로 상위클래스의 해당 생성자를 호출해야 함
- super를 이용하여 상위클래스의 멤버 변수나 메소드에 접근할 수 있다.


# 상속은 언제 사용할까 ?

## 1. IS-A 관계(is a relationship : inheritance)

- 일반적인(general) 개념과 구체적인(specific) 개념과의 관계
- 상위 클래스 : 하위 클래스보다 일반적인 개념 ( 예: Employee )
- 하위 클래스 : 상위 클래스보다 구체적인 개념들이 더해짐 ( 예: Engineer, Manager...)
- 상속은 클래스간의 결합도가 높은 설계
- 상위 클래스의 수정이 많은 하위 클래스에 영향을 미칠 수 있음
- 계층구조가 복잡하거나 hierarchy가 높으면 좋지 않음

## 2. HAS-A 관계(composition)

- 클래스가 다른 클래스를 포함하는 관계 ( 변수로 선언 )
- 코드 재사용의 가장 일반적인 방법
- Student가 Subject를 포함하는
- Library를 구현할 때 ArrayList 생성하여 사용하는 것처럼
- 상속하지 않음


# 형 변환 (업캐스팅)

- 상위클래스로 변수를 선언하고 하위클래스로 인스턴스 생성
    
    `Customer customerKim = new VIPCustomer();`
    
- 하위클래스는 상위클래스의 타입을 내포하고 있으므로 묵시적 형변환이 일어난다
- 역은 불가능
- 형 변환 시 상위클래스의 멤버변수와 메소드에만 접근할 수 있다. (상위 클래스에 없는 하위 클래스에서 새로 작성한 메소드 사용 불가)


## 형 변환과 오버라이딩 메소드 호출

```java
class VCustomer extends Customer

Customer vCustomer = new VIPCustomer();
```

- vCustomer의 변수 타입은 Customer지만, 인스턴스 타입은 VIPCustomer
- 자바에서는 항상 인스턴스의 메소드가 호출된다(가상 메소드의 원리)
- 자바의 모든 메소드는 가상 메소드


## 메소드는 어떻게 실행되고 호출되는가?

- 메소드의 이름은 주소값을 나타냄
- 메소드 영역은 명령어의 set이고 프로그램이 로드되면 메소드 영역에 명령어 set이 위치
- 해당 메소드가 호출되면 명령어 set이 있는 위치를 찾아가 실행
- 이때 메소드에서 사용하는 변수들은 스택메모리에 위치
- 따라서 다른 인스턴스라도 같은 메소드의 코드는 같으므로 같은 메소드가 호출됨

```java
public class TestMethod {

	int num;
	
	void aaa() {
		System.out.println("aaa() 호출");
	}
	
	public static void main(String[] args) {
		
		TestMethod a1 = new TestMethod();
		a1.aaa();
		
		TestMethod a2 = new TestMethod();
		a2.aaa();
	}

}
```

![image](https://user-images.githubusercontent.com/106129404/225195419-bc63698f-9936-4210-8a8a-83a6fe21e440.png)


## 가상 메소드의 원리

- 가상 메소드 테이블은 해당 메소드에 대한 address를 가지고 있다
- 재정의된 경우에는 재정의된 가상메소드를 가리킴

```java
class VCustomer extends Customer

Customer vC = new VIPCustomer();
vC.calcPrice();
```

![image](https://user-images.githubusercontent.com/106129404/225195455-b12bf055-5c81-4c15-a4aa-72b97ee2f60c.png)

![image](https://user-images.githubusercontent.com/106129404/225195473-6e310d9a-9c15-41ac-886c-a6ebd712d2a7.png)


# 다형성(polymorphism)

- 클래스가 데이터 타입에 따라 다양한 형태로 보여질 수 있는 성질
- 클래스의 인스턴스를 변수로 선언할 때, 해당 클래스의 데이터 타입으로 선언하지 않고 부모 클래스나 인터페이스를 변수 타입으로 선언할 수 있다.
- 인스턴스 변수에 같은 인터페이스를 가진 각기 다른 클래스들을 생성한다.
- 하나의 코드가 여러 자료형으로 구현되어 실행되고, 각각 다른 실행 결과가 나온다.
- 코드를 수정할 때 클래스에 상속관계가 있다면 적은 코드 양으로 유지보수하기 쉽게 수정할 수 있다.
- 즉, 유연하고 확장성있고, 유지보수가 편리한 프로그램을 만들수 있음


## 다형성을 사용하는 이유
- 상속과 메소드 오버라이딩을 활용하여 확장성 있는 프로그램을 만들 수 있다.
- 그렇지 않은 경우 수많은 if-else if문이 만들어지고 유지보수가 어려워진다.

![image](https://user-images.githubusercontent.com/106129404/225195763-27f8249e-08ee-437e-b21b-7a6d64cd28b9.png)

- 이렇게 if문을 하나하나 돌면서 명령문을 추가할 게 아니라, 각각의 클래스에서 상속받아 오버라이딩하고 이를 다형성으로 관리한다.
- 상위클래스에서는 공통적인 부분을 제공하고 하위클래스에서는 각 클래스에 맞는 기능 구현
- 여러 클래스들을 하나의 타입(상위클래스)로 핸들링 할 수 있다.

## 다운캐스팅

- 업캐스팅한 클래스를 다시 원래의 타입으로 형 변환
- 하위클래스로의 형 변환은 명시적으로 한다.

```java
Customer vc = new VIPCustomer();              //묵시적 형변환(업캐스팅)
VIPCustomer vCustomer = (VIPCustomer)vc;      //명시적 형변환(다운캐스팅)
```

## instanceof를 사용하여 인스턴스의 형 체크

- instanceof는 인스턴스의 형이 맞는지 여부를 체크하는 키워드. boolean 타입을 반환한다.
- instanceof를 이용하여 체크하지 않고 잘못된 형으로 다운캐스팅하면 `ClassCastException`

```java
public void testDownCasting(ArrayList<Animal> list) {
		
		for(int i =0; i<list.size(); i++) {
			Animal animal = list.get(i);
		
			if ( animal instanceof Human) {
				Human human = (Human)animal;
				human.readBooks();
			}
			else if( animal instanceof Tiger) {
				Tiger tiger = (Tiger)animal;
				tiger.hunting();
			}
			else if( animal instanceof Eagle) {
				Eagle eagle = (Eagle)animal;
				eagle.flying();
			}
			else {
				System.out.println("error");
			}
		
		}
}
```

<br>

# 추상클래스


## 추상클래스란?

- 구현 코드 없이 메소드의 선언만 있는 추상 메소드를 포함한 클래스
- 메소드 선언 : 메소드 이름, 반환 타입, 매개변수로 구성
- 메소드 정의 : 메소드 선언과 의미 구현부 {} 를 가짐

```java
int add(int a, int b); // 메소드 선언, 추상 메소드
int add(int a, int b) { return a+b } // 메소드 정의(구현)
```

- abstract 사용
- 추상 클래스는 new로 인스턴스를 생성할 수 없음
- 인스턴스 변수의 타입으로 다형성은 가능


## 추상클래스 구현하기

- 메소드에 구현 코드가 없으면 abstract 선언
- abstract 메소드를 하나라도 가진 클래스는 abstract 선언
- 모든 메서드가 구현 된 클래스라도 abstract로 선언되면 추상 클래스로 인스턴스화 할 수 없음
- 추상 클래스내의 추상 메소드는 하위클래스가 상속하여 구현
- 추상 클래스내의 구현된 메소드는 하위클래스가 공통으로 사용, 필요에 따라 오버라이딩


## 템플릿 메소드

- 추상 메소드와 구현 메소드를 활용하여 코드의 흐름(시나리오)을 정의하는 메소드
- 프레임워크에서 많이 사용되는 설계패턴
- final로 선언하여 하위 클래스에서 오버라이딩할 수 없게 함
- 추상 클래스로 선언된 상위 클래스에서 템플릿 메서드를 활용하여 전체적인 흐름을 정의 하고 하위 클래스에서 다르게 구현되어야 하는 부분은 추상 메서드로 선언하여 하위 클래스에서 구현 하도록 함
- 하위클래스에서 오버라이딩 된 추상메소드 + 구현메소드로 시나리오 구현


### 템플릿 메소드 예제

![image](https://user-images.githubusercontent.com/106129404/225196156-00b9d3b8-a816-4373-b5e2-8845e5058fd0.png)

```java
public abstract class Car {
	
	public abstract void drive();
	public abstract void stop();
	
	public void startCar() {
		System.out.println("시동을 켭니다.");
	}
	
	public void turnOff() {
		System.out.println("시동을 끕니다.");
	}

	public void washCar() {} // hook method
			
	final public void run() {
		startCar();
		drive();
		stop();
		turnOff();
		washCar();
	}
}
```


## hookup method

- 강제적으로 implement 해야하는 추상 메소드와 달리, 선택적으로 오버라이딩하여 구현할 수 있는 메소드
- 추상 클래스에 들어있는 아무 일도 하지 않거나 기본 행동을 정의하는 메소드로, 서브 클래스에서 오버라이드 할 수 있다.
- 오버라이딩을 해도 되고, 안해도 된다.


## final 예약어

- fianl 변수 : 값이 변경될 수 없는 상수
- final 메소드 : 오버라이딩 할 수 없는 메소드
- final 클래스 : 상속할 수 없는 클래스

<br>

# 인터페이스 (implements)

- 인터페이스는 규격이다.
- 클래스가 작성해야할 메소드의 이름과 매개변수, 리턴타입을 정해서 규격한다.
- 모든 변수는 상수, 모든 메소드는 추상 메소드로 선언됨
- 클래스는 여러개의 인터페이스를 구현 가능
- 인터페이스의 변수는 값을 정의하며 각 클래스에서 호출 가능하다.
- 인터페이스는 메소드의 동작방식을 통일하는데에 도움을 준다. ex) Interface AutoCloseable은 close() 메소드를 구현해야 하는데, 이 인터페이스를 상속받은 모든 클래스들은 close()메소드를 사용할 수 있고 이를 통해 작업을 종료한다.
- 다른 사람과 협업할 때, 기능을 명확히 하고 싶을 때 사용한다.
- 클래스의 기능이 너무 많아져서, 선택적으로 사용자에게 제공하고 싶어질 때 사용한다.
- 여러 목적의 클래스들을 공통적으로 기능적으로 묶고자 할 때 사용한다.
- 인터페이스를 구현한 클래스는 인터페이스 형으로 선언한 변수로 형 변환 가능(상속과 동일)


## 인터페이스와 다형성

- 하나의 인터페이스를 여러가지 객체가 구현하고, 구현된 여러가지 객체를 경우에 따라 선택하며 사용 가능
- 클라이언트는 객체가 어떻게 구현되어 있는지와 상관없이, 인터페이스의 메소드를 활용하여 객체들을 사용할 수 있다.
- 예시
    
  ![image](https://user-images.githubusercontent.com/106129404/225196318-bad8a773-d83c-4ec9-9672-2d504f523b31.png)
    
  ![image](https://user-images.githubusercontent.com/106129404/225196344-f1546e58-0c1a-4b54-aadf-6ab129591cb4.png)
    

## default 메소드(Java 8 이후)

- 인터페이스를 구현하는 클래스들이 공통적으로 사용가능한 메소드
- default 키워드 사용
- 구현하는 클래스에서 재정의 할 수 있다.
- 인터페이스를 구현하는 클래스의 인스턴스가 생성되어야 사용 가능


## default 메소드가 중복되는 경우

- 두 개 이상의 인터페이스에서 상속받은 default메소드가 중복되는 경우 반드시 클래스에서 Overriding 해야한다.


## 정적 메소드(Java 8 이후)

- 인스턴스의 생성과 상관없이 인터페이스타입으로 사용 가능한 메소드
- static 키워드 사용


## private 메소드(Java 9 이후)

- 인터페이스를 구현한 클래스에서 구현하거나 사용할 수 없음
- 인터페이스 내부에서만 사용 가능한 메소드
- default나 static에서 사용


## 인터페이스의 상속

- 인터페이스 사이에도 상속할 수 있음
- extends 키워드 사용
- 인터페이스는 다중 상속이 가능
- 구현 상속이 아닌 타입 상속

<br>

# 내부 클래스
- 클래스 내부에 선언한 클래스
- 다른 외부 클래스에서 사용할 일이 없고 해당 외부 클래스 내에서만 사용할 클래스가 필요할 경우에 사용
- 중첩(nested)클래스 라고도 함
- 내부클래스의 종류 : 인스턴스 내부 클래스, 정적(static)내부 클래스, 지역(local) 내부 클래스, 익명(ananymous) 내부 클래스

![image](https://user-images.githubusercontent.com/106129404/230264203-2942d4db-4844-4ad0-8edb-a1e1b406b3ec.png)

## 인스턴스 내부 클래스
- 내부적으로 사용할 클래스 선언
- priavte으로 사용하는 것을 권장, 외부클래스의 생성자에 주로 생성
- 외부클래스가 생성된 후 생성됨
- private이 아닌 내부클래스는 다른 외부 클래스에서도 생성할 수 있음
- 자바 16부터는 인스턴스 내부 클래스에 static 변수와 static 메소드 사용 가능
- 외부참조가 생성되어 메모리 누수가 발생
- 외부 클래스의 인스턴스 멤버 사용 가능

```java
class OutClass {

	private int num = 10;
	private static int sNum = 20;
	private InClass inClass;
	
	public OutClass(){
		inClass = new InClass(); // 내부 클래스 생성
	}
	
	class InClass{
		
		int inNum = 100;
		static int sInNum = 200;  //자바 16부터 사용가능
		
		void inTest(){
			System.out.println("OutClass num = " +num + "(외부 클래스의 인스턴스 변수)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수)");
			System.out.println("InClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수)");
		    System.out.println("InClass sInNum = " + sInNum + "(내부 클래스의 정적 변수)");
		}
		
	    static void sTest(){  //자바 16부터 사용가능
	    	System.out.println("inner static method" + sInNum);
	    }
		
	}
	
	public void usingClass(){
		inClass.inTest(); //내부 클래스 변수를 사용하여 메서드 호출하기
	}
}
```

## 정적 내부 클래스
- 외부 클래스 생성과 무관하게 사용 가능
- 정적 변수, 정적 메서드 사용
- 외부 클래스의 인스턴스 멤버 사용 불가
- 내부 클래스는 static으로 사용하는 것이 메모리 누수가 없다
- 정적 내부 클래스에서의 일반 메소드와 정적 메소드의 변수 사용 범위
![image](https://user-images.githubusercontent.com/106129404/230265610-9890aee5-e2b3-4e51-8f22-0aeaa6a71b05.png)

```java
class OutClass {

	private int num = 10;
	private static int sNum = 20;
	private InClass inClass;

	static class InStaticClass {
		
		int inNum = 100;
		static int sInNum = 200;
		
		void inTest() {   //정적 클래스의 일반 메서드
			//num += 10;    // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			System.out.println("InStaticClass inNum = " + inNum + "(내부 클래스의 인스턴스 변수 사용)"); 
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
		}
		
		static void sTest() {  // 정적 클래스의 static 메서드
			//num += 10;   // 외부 클래스의 인스턴스 변수는 사용할 수 없음.
			//inNum += 10; // 내부 클래스의 인스턴스 변수는 사용할 수 없음
			
			System.out.println("OutClass sNum = " + sNum + "(외부 클래스의 스태틱 변수 사용)");
			System.out.println("InStaticClass sInNum = " + sInNum + "(내부 클래스의 스태틱 변수 사용)");
			
		}
	}	
}
```

## 지역 내부 클래스
- 지역 변수와 같이 메소드 내부에서 사용하는 클래스
- 메소드의 호출이 끝나면 지역변수의 유효성은 사라진다.
- 지역 내부 클래스는 메소드가 호출 종료된 이후에도 계속 사용할 수 있으므로, 생명주기가 감싸고 있는 메소드보다 길 수 있다.
- 그러므로 둘러싼 메소드의 매개변수와 지역변수들은 지역 내부 클래스 내에서 final(상수)로 변한다.
- 따라서 지역 내부 클래스내에서 임의로 외부 메소드의 매개변수나 지역변수의 값을 변경할 수 없다.

```java
Runnable getRunnable(int i){

		int num = 100;
		
		class MyRunnable implements Runnable{

			int localNum = 10;
				
			@Override
			public void run() {
				//num = 200;   //에러 남. 지역변수는 상수로 바뀜
				//i = 100;     //에러 남. 매개 변수 역시 지역변수처럼 상수로 바뀜
				System.out.println("i =" + i); 
				System.out.println("num = " +num);  
				System.out.println("localNum = " +localNum);
					
				System.out.println("outNum = " + outNum + "(외부 클래스 인스턴스 변수)");
				System.out.println("Outter.sNum = " + Outer.sNum + "(외부 클래스 정적 변수)");
				}
			}
		 return new MyRunnable();
	}
```

## 익명 내부 클래스
- 이름이 없는 클래스
- 지역 내부 클래스는 한번 호출될 때에만 변수 이름이 사용되기 때문에 익명 내부 클래스로 구현한다.
- 클래스의 이름을 생략하고 주로 하나의 인터페이스나 추상클래스를 구현하여 반환
- 지역 내부 클래스처럼 메서드 내부에서 생성하여 반환하거나
- 인터페이스나 추상 클래스 자료형의 변수에 직접 대입하여 클래스를 생성하고 반환한다.

```java
class Outter{
		
	Runnable getRunnable(int i){

		int num = 100;
		
		return new Runnable() {
				
		@Override
		public void run() {
			//num = 200;   //에러 남
			//i = 10;      //에러 남
			System.out.println(i);
			System.out.println(num);
			}
		};
	}
	
	Runnable runner = new Runnable() {
		
		@Override
		public void run() {
			System.out.println("Runnable 이 구현된 익명 클래스 변수");
			
		}
	};
}
```
