# 목차

<!-- TOC tocDepth:1..3 chapterDepth:1..6 -->

- [목차](#목차)
- [변수](#변수)
    - [변수의 명명규칙](#변수의-명명규칙)
- [변수의 타입](#변수의-타입)
    - [기본 자료형(Primitive Type)](#기본-자료형primitive-type)
    - [참조 자료형](#참조-자료형)
- [리터럴](#리터럴)
- [부동 소수점 방식](#부동-소수점-방식)
- [자바의 문자 표현](#자바의-문자-표현)
- [자료형 없이 변수 사용하기](#자료형-없이-변수-사용하기)
- [형변환 (Casting)](#형변환-casting)
    - [문자(char)를 정수(int)로 형변환 하는법](#문자char를-정수int로-형변환-하는법)

<!-- /TOC -->

## 변수
- 변수란, 단 하나의 값을 저장할 수 있는 메모리 공간

### 변수의 명명규칙
1. 대소문자가 구분되며 길이에 제하니 없다.
2. 예약어를 사용해서는 안 된다.
3. 숫자로 시작해서는 안 된다.
4. 특수문자는 `_`와 `$`만을 허용한다.
5. 클래스 이름의 첫 글자는 대문자로 한다.
6. 여러 단어로 이루어진 이름은 단어의 첫 글자를 대문자로 한다.
7. 상수의 이름은 모두 다문재로 한다. 여러 단어로 이루어진 경우 `_`로 구분한다.

## 변수의 타입

###  기본 자료형(Primitive Type)

- boolean(1byte)
- byte(1byte)
- short(2byte)
- int(4byte)
- long(8byte)
- float(4byte)
- double(8byte)
- character(2byte)

### 참조 자료형

- 클래스형으로 변수를 선언
- 기본 자료형은 메모리의 크기가 정해져있지만, 참조 자료형은 클래스마다 다름.
- 참조 자료형을 사용할 때는 해당 변수에 대해 생성해야 한다.
    - String은 예외적으로 생성하지 않고 사용할 수 있다.



## 리터럴

- 프로그램에서 사용하는 숫자, 문자, 논리값을 뜻함
- 리터럴은 상수 풀에 있음
- 정수리터럴은 int, 실수리터럴은 double로 저장됨
- int는 자바의 정수 리터럴이므로, long형을 사용하고 싶을 때에는 식별자 L로 명시한다.
    - ex) long lNum = 123456789999L;
- double은 자바의 실수 리터럴이므로, float형으로 사용하고 싶을 때에는 식별자 F로 명시한다.
    - ex) float fNum = 3.14F;




## 부동 소수점 방식

- 실수는 정수보다 정밀하기 때문에 정수와 다른 방식으로 표현

![image](https://user-images.githubusercontent.com/106129404/225188246-3880119e-d2bc-45ce-a223-82e46b6f5d7a.png)

- 컴퓨터의 밑수는 2이고, 지수부와 가수부로 비트를 나누어 포현
- 정규화 : 가수가 밑수보다 작은 한자리까지 가수로 표현하는 것
- 지수와 가수로 나타내는 부동 소수점 방식에서는 지수부가 0을 표현할 수 없기 때문에 **약간의 오차가 발생**할 수 있음
    - 예시
        
        ```
        		double myNum = 1;
        		for(int i =0; i<10000; i++) {
        			myNum = myNum + 0.1;
        		}
        		System.out.print(myNum); 
        }
        
        1001.000000000159 // 지수부가 완전한 0을 표현할 수 없다.
        ```
        



## 자바의 문자 표현

- encoding : 문자 → 숫자
- decoding : 숫자 → 문자
- 자바에서는 어떤 문자를 나타내기 위해서 특정 정수값을 정의
- 자바에서는 전세계 표준 문자세트인 UNICODE 사용 (utf-16 인코딩)
- 문자는 항상 양수이므로 음수 assign 불가능
- 유니코드 표현은 \u

```jsx
char ch1 = '\uD55C';
// 유니코드는 16진수로 표현되어 각 자리수마다 2^4개의 정보를 4자리로 표현한다.
// 즉 , (2^4)^4 = 2^16 = 2바이트이므로 utf-16 유니코드 자바는 2바이트를 사용한다.
```

- Java에서는 String은 “” 큰따옴표, Character은 ‘’ 작은 따옴표로 구분한다.



## 자료형 없이 변수 사용하기

- 자바 10이상부터 지원됨
- 지역변수에서만 사용 가능 (인스턴스 변수에서 X)
- 컴파일 타임에 추론됨
- 한번 추론된 변수에 다른 타입의 값을 대입할 수 없음
- 반드시 변수를 초기화 해야함
- null값을 가질 수 없음



## 형변환 (Casting)

- 서로 다른 자료형의 연산을 위해 하나의 자료형으로 통일하는 것
- 묵시적 형 변환(자동)과 명시적 형 변환(강제)이 있음
- 바이트 크기가 작은 자료형에서 큰 자료형은 자동으로 이루어짐
- 덜 정밀한 자료형에서 정밀한 자료형은 자동으로 이루어짐
- upcasting : 작은 크기의 데이터에서 큰 크기의 데이터로 옮기는 것. 자동으로 형변환 됨
ex) double a = 1;
- downcasting : 큰 크기의 데이터에서 작은 크기의 데이터로 옮기는 것. 강제 형변환 필요
ex) int a =(int) 1.1; → 데이터 손실이 발생할 수 있음



### 문자(char)를 정수(int)로 형변환 하는법

**1. 자동 형변환, 강제 형변환 (X)**

```xml
char c = '1';
int n = c; // == int n = (int)c;

System.out.println(n); // 결과: 49
```

자동 형변환이나 강제 형변환으로 char를 int로 변경하면 문자 '1'의 아스키 코드인 49가 출력된다


**2. '0'을 빼주기 (ASCII code 사용) (O)**

```xml
char c = '1';
int n = c - '0'; // == int n = (int)c - '0'; 49 - 48 = 1

System.out.println(n); // 결과: 1
```

아스키 코드 표를 살펴보면 문자 0 ~ 9는 48 ~ 57의 순서로 되어있다.
따라서 문자 '1'의 아스키 코드에서 문자 '0'의 아스키 코드를 빼주면 원하는 숫자가 나온다.


**3. Character.getNumericValue() (O)**

```xml
char c = '1';
int n = Character.getNumericValue(c);

System.out.println(n); // 결과: 1
```

자바의 Character 클래스에서 Character.getNumericValue() 함수를 사용하면 같은 결과를 좀 더 깔끔한 코드로 얻을 수 있다.
